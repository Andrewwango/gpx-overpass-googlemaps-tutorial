[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "How to find places along a GPX route in Python using Overpass API and Google Maps Places API",
    "section": "",
    "text": "Do you have some long GPX routes, for long hikes, pub crawls or pilgrimages? How can you automatically find what amenities are near the route, and reduce the amount you spend using paid APIs?\nIn this tutorial, we find places in OpenStreetMap along our route, using the free Overpass API. Then, we use the Google Maps Places API for each place of interest to retrieve up-to-date place ratings, reviews, photos and opening hours.\nDoing it this way has a couple of advantages:\nWhat we need to do is:\nFor the full notebook, see the repo.\nLet’s get started!\nCreate a virtual environment: python -m venv venv, source venv/Scripts/activate\nYou will need to pip install the following packages (pip install -r requirements.txt):\nimport numpy as np\nimport pandas as pd"
  },
  {
    "objectID": "blog.html#import-gpx-route",
    "href": "blog.html#import-gpx-route",
    "title": "How to find places along a GPX route in Python using Overpass API and Google Maps Places API",
    "section": "1. Import GPX route ",
    "text": "1. Import GPX route \nWe will be using a sample GPX route describing a pilgrimage in the Peak District, United Kingdom, which you can download from the British Pilgrimage Trust website. The route is 63km long and wanders through small villages and beautiful countryside.\nAfter downloading the route, read the GPX using the gpxpy package and convert to a pandas DataFrame (this handles both routes and tracks):\n\nfrom gpxpy import parse\n\nwith open(\"Peak Pilgrimage.gpx\") as f:\n    p = parse(f)\n    points = [(point.latitude, point.longitude) for route in p.routes for point in route.points] + \\\n             [(point.latitude, point.longitude) for track in p.tracks for segment in track.segments for point in segment.points]\n    input_df = pd.DataFrame(points, columns=[\"latitude\", \"longitude\"])\n\nThe route might look like this:\n\ninput_df.head()\n\n\n\n\n\n\n\n\nlatitude\nlongitude\n\n\n\n\n0\n53.053368\n-1.803243\n\n\n1\n53.053603\n-1.803120\n\n\n2\n53.053691\n-1.802744\n\n\n3\n53.053987\n-1.802573\n\n\n4\n53.054065\n-1.802433\n\n\n\n\n\n\n\nPlot the route on a map:\n\n\nPython function to plot a GPX route and POIs to a HTML map using Folium\nimport folium\n\ndef folium_route(route_lats: pd.DataFrame, \n                 route_lons: pd.DataFrame, \n                 pois=[], popup_func=lambda x,y: None) -&gt; folium.folium.Map:\n    \n    # Initialise map at centre of route\n    m = folium.Map([route_lats.mean(), route_lons.mean()], zoom_start=10)\n    \n    # Add route to map\n    folium.PolyLine(list(zip(route_lats, route_lons))).add_to(m)\n    \n    # If displaying POIs, plot as circles with popups\n    for i in range(len(pois)):\n        folium.CircleMarker(location=pois.loc[i, [\"lat\", \"lon\"]].to_list(), fill=True) \\\n              .add_child(folium.Popup(popup_func(pois, i), max_width=500))             \\\n              .add_to(m)\n        \n    return m\n\n\n\nfolium_route(input_df[\"latitude\"], input_df[\"longitude\"])\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook"
  },
  {
    "objectID": "blog.html#find-nearby-places-along-the-route-using-overpass-api",
    "href": "blog.html#find-nearby-places-along-the-route-using-overpass-api",
    "title": "How to find places along a GPX route in Python using Overpass API and Google Maps Places API",
    "section": "2. Find nearby places along the route using Overpass API ",
    "text": "2. Find nearby places along the route using Overpass API \nWe use the free Overpass API to find places from OpenStreetMap along our GPX route. The overpy library lets us do this in Python:\n\nimport overpy \napi = overpy.Overpass()\n\nFlatten the route coordinates into a string:\n\ninput_latlons = \",\".join(input_df.to_numpy().flatten().astype(\"str\"))\n\nConstruct the Overpass query in Overpass Query Language. See here for a great intro.\n\nnwr tells Overpass to find nodes, ways and relations (explanation).\namenity is a key-value tag describing facilities such as pubs, see here for a complete list.\nhistoric describes features of historic interest, see here for a complete list.\naround:1000 finds features within 1000m of the input route.\n\n\noverpass_query = f\"\"\"\n[out:json][timeout: 500];\n(nwr[\"amenity\" = \"place_of_worship\"](around:1000,{input_latlons});\nnwr[\"amenity\" = \"pub\"](around:1000,{input_latlons});\nnwr[\"historic\" = \"memorial\"](around:1000,{input_latlons});\nnwr[\"historic\" = \"wayside_cross\"](around:1000,{input_latlons});\nnwr[\"historic\" = \"wayside_chapel\"](around:1000,{input_latlons});\nnwr[\"historic\" = \"wayside_shrine\"](around:1000,{input_latlons});\nnwr[\"historic\" = \"archaeological_site\"](around:1000,{input_latlons});\nnwr[\"historic\" = \"stone\"](around:1000,{input_latlons});\nnwr[\"historic\" = \"milestone\"](around:1000,{input_latlons});\nnwr[\"historic\" = \"boundary_stone\"](around:1000,{input_latlons});\nnwr[\"historic\" = \"tomb\"](around:1000,{input_latlons});\nnwr[\"historic\" = \"archaeological_site\"](around:1000,{input_latlons});\nnwr[\"water_source\" = \"well\"](around:1000,{input_latlons});\n  ( ._; &gt;; );\n);\nout center;\n\"\"\"\n\n\nresult = api.query(overpass_query)\n\nThe Overpass result is returned as a list of nested objects, which we need to map to a json dictionary. The following pandas steps then loads the results into a DataFrame and removes all results with an empty name field:\n\nresult_df = pd.json_normalize(map(vars, result.nodes)) \\\n              .drop(columns=[\"_result\"]) \\\n              .rename(columns={\"tags.name\": \"name\"}) \\\n              .dropna(subset=['name']) \\\n              .reset_index(drop=True)\n\nWe see that Overpass gives us a rich set of results directly from OpenStreetMap:\n\nresult_df.columns\n\nIndex(['id', 'lat', 'lon', 'tags.addr:city', 'tags.addr:postcode',\n       'tags.addr:street', 'tags.addr:village', 'tags.amenity', 'tags.fhrs:id',\n       'name', 'tags.food', 'tags.outdoor_area', 'tags.parking',\n       'tags.real_ale', 'tags.source:postcode', 'tags.wikidata',\n       'tags.accommodation', 'tags.floor:material', 'tags.internet_access',\n       'tags.internet_access:fee', 'tags.toilets', 'tags.toilets:wheelchair',\n       'tags.website', 'tags.wheelchair', 'tags.opening_hours:signed',\n       'tags.operator', 'tags.note', 'tags.archaeological_site',\n       'tags.historic', 'tags.site_type', 'tags.source', 'tags.wikipedia',\n       'tags.denomination', 'tags.ele', 'tags.religion', 'tags.memorial',\n       'tags.tourism', 'tags.megalith_type', 'tags.addr:housename',\n       'tags.sport', 'tags.inscription', 'tags.heritage'],\n      dtype='object')\n\n\n\nresult_df.head()\n\n\n\n\n\n\n\n\nid\nlat\nlon\ntags.addr:city\ntags.addr:postcode\ntags.addr:street\ntags.addr:village\ntags.amenity\ntags.fhrs:id\nname\n...\ntags.denomination\ntags.ele\ntags.religion\ntags.memorial\ntags.tourism\ntags.megalith_type\ntags.addr:housename\ntags.sport\ntags.inscription\ntags.heritage\n\n\n\n\n0\n251982730\n53.2459014\n-1.6133234\nBakewell\nDE45 1SR\nNether End\nBaslow\npub\n258157\nThe Devonshire Arms\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n1\n251985589\n53.2465269\n-1.6124122\nBakewell\nDE45 1SR\nNether End\nBaslow\npub\n258453\nThe Wheatsheaf\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n2\n251986045\n53.2661742\n-1.6310557\nNaN\nS32 3XA\nCalver Bridge\nNaN\npub\n258965\nThe Bridge Inn\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n3\n251986258\n53.2683640\n-1.6411023\nNaN\nNaN\nNaN\nNaN\npub\nNaN\nThe Derwentwater Arms\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n4\n305916852\n53.2814117\n-1.6312423\nNaN\nNaN\nNaN\nNaN\npub\nNaN\nThe Chequers\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n\n\n5 rows × 42 columns\n\n\n\nClick on the points of interest (POI) to see their name:\n\nfolium_route(input_df[\"latitude\"],\n             input_df[\"longitude\"], \n             pois=result_df, \n             popup_func=lambda p,i: f\"POI {i}: {p.loc[i,'name']}\")\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\nThe eagle-eyed would notice that the POIs aren’t listed in the order of the route! This can present some problems. Let us use reorder them using some distance-based matching:\n\nCalculate pairwise distances between POIs and route points\nFind closest route point for each POI\nReorder POIs by closest route points\n\n\nfrom sklearn.metrics.pairwise import haversine_distances as hd\n\npairwise_distances = hd(np.deg2rad(input_df[[\"latitude\", \"longitude\"]].to_numpy()), \n                        np.deg2rad(result_df[[\"lat\", \"lon\"]].to_numpy())) \\\n\nresult_df[\"closest\"] = pairwise_distances.argmin(axis=0)\n\npois = result_df.sort_values(\"closest\")\n\n\npois = pois[[\"id\", \"lat\", \"lon\", \"name\"]].reset_index(drop=True)"
  },
  {
    "objectID": "blog.html#get-full-details-of-pois-using-google-maps-places-api",
    "href": "blog.html#get-full-details-of-pois-using-google-maps-places-api",
    "title": "How to find places along a GPX route in Python using Overpass API and Google Maps Places API",
    "section": "3. Get full details of POIs using Google Maps Places API ",
    "text": "3. Get full details of POIs using Google Maps Places API \nFor each of our POIs on the route, we want to quickly grab their website, photos, and ratings. Inevitably, OpenStreetMap has limited and incomplete data on all of our detected places. Here we use the Google Maps Places API to get those details.\nTo get started with the API, grab an API key from the Google Maps Platform (paid service). Note that all projects get a free monthly allowance which will be more than enough for us: see billing for details.\nThe googlemaps Python SDK allows us to connect to the Places API in Python (copy-paste your personal API key in):\n\nimport googlemaps\n\ngmaps = googlemaps.Client(key=\"\")\n\nFirst we perform a “Nearby Places” search to get the corresponding Google Maps place for each OSM place, by providing Google Maps with both the location and the OSM name of the place.\n\npoi_lat_lon_names = list(pois[[\"lat\", \"lon\", \"name\"]].itertuples(index=False, name=None))\n\n\nfrom tqdm import tqdm\n\nresults = [gmaps.places_nearby(keyword=name, location=[lat, lon], radius=5) \\\n           for (lat, lon, name) in tqdm(poi_lat_lon_names)]\n\n100%|███████████████████████████████████████████| 26/26 [00:14&lt;00:00,  1.75it/s]\n\n\nCoax the results into a clean json format for loading into a DataFrame:\n\nresults = [result[\"results\"][0] if len(result[\"results\"]) &gt; 0 else {\"business_status\": np.nan} for result in results]\n\n\ngmaps_df = pd.json_normalize(results)\n\nNow, extract useful fields for our POIs:\n\nName on Google Maps\nAverage user rating and number of rating\nType of place according to Google Maps\nPrice level\nGoogle URL\nUser uploaded photo\n\n\npois[[\"google_name\", \"rating\", \"types\", \"n_ratings\", \"price_level\"]] = \\\n    gmaps_df[[\"name\", \"rating\", \"types\", \"user_ratings_total\", \"price_level\"]]\n\npois[\"url\"] = gmaps_df[\"place_id\"].map(lambda x: f\"https://www.google.com/maps/place/?q=place_id:{x}\")\n\nPerform a “Place Photos” search to obtain user photos from Google Maps. The photos are returned in byte chunks.\n\nfrom io import BytesIO\nimport base64\n\ndef get_photo_bytes(photo: list) -&gt; str:\n    if isinstance(x, list) and len(x) &gt; 0:\n        \n        # Get top returned photo ID\n        photo_id = photo[0][\"photo_reference\"]\n        \n        # Get raw bytes of photo from Google Maps Place Photos search\n        b = b\"\".join(gmaps.places_photo(photo_id, max_width=100))\n        \n        # Encode into base64 for HTML display\n        return base64.b64encode(BytesIO(b).getvalue()).decode()        \n    else:\n        return \"\"\n\n\npois[\"photo_bytes\"] = gmaps_df[\"photos\"].map(get_photo_bytes)\n\nGoogle Maps has given us a lot more detail than the original OSM places!\n\npois.head()\n\n\n\n\n\n\n\n\nid\nlat\nlon\nname\ngoogle_name\nrating\ntypes\nn_ratings\nprice_level\nurl\nphotos\nphoto_id\nphoto_bytes\n\n\n\n\n0\n3362045361\n53.141174\n-1.809284\nRoyal British Legion\nRoyal British Legion, Cavendish House\n4.8\n[bar, point_of_interest, establishment]\n8.0\nNaN\nhttps://www.google.com/maps/place/?q=place_id:...\nAW30NDzDoXCGbKue-GlnzehJqq02gCrxEeV5oBn0rrZYBq...\nAW30NDzDoXCGbKue-GlnzehJqq02gCrxEeV5oBn0rrZYBq...\n/9j/4AAQSkZJRgABAQAAAQABAAD/4QAqRXhpZgAASUkqAA...\n\n\n1\n410871346\n53.140523\n-1.809675\nDevonshire Arms\nThe Devonshire Arms\n4.1\n[bar, restaurant, food, point_of_interest, est...\n627.0\n2.0\nhttps://www.google.com/maps/place/?q=place_id:...\nAW30NDxJj-kzaTz5yIR9sfw9mFd3ApawYQynbViq0VNPLE...\nAW30NDxJj-kzaTz5yIR9sfw9mFd3ApawYQynbViq0VNPLE...\n/9j/4AAQSkZJRgABAQAAAQABAAD/4QAqRXhpZgAASUkqAA...\n\n\n2\n3362042956\n53.140606\n-1.808380\nWar Memorial\nNaN\nNaN\nNaN\nNaN\nNaN\nhttps://www.google.com/maps/place/?q=place_id:nan\nNaN\nNaN\n\n\n\n3\n8289562776\n53.193764\n-1.826558\nCronkston Low Bowl Barrow\nNaN\nNaN\nNaN\nNaN\nNaN\nhttps://www.google.com/maps/place/?q=place_id:nan\nNaN\nNaN\n\n\n\n4\n414090489\n53.195983\n-1.776546\nThe Bulls Head\nThe Bulls Head\n4.6\n[bar, restaurant, point_of_interest, food, est...\n1082.0\n2.0\nhttps://www.google.com/maps/place/?q=place_id:...\nAW30NDxZpxIryMv0BWcYDKa-SIe1_LYizfasNIMfgwh3-2...\nAW30NDxZpxIryMv0BWcYDKa-SIe1_LYizfasNIMfgwh3-2...\n/9j/4AAQSkZJRgABAQAAAQABAAD/4QAqRXhpZgAASUkqAA..."
  },
  {
    "objectID": "blog.html#display-final-map",
    "href": "blog.html#display-final-map",
    "title": "How to find places along a GPX route in Python using Overpass API and Google Maps Places API",
    "section": "4. Display final map ",
    "text": "4. Display final map \nTime to display the final results in a map. Click on the POIs to get a full popup with Google Maps details and photos! Note some POIs weren’t detected in Google. These are, for example, war memorials that a user has added to OSM but haven’t yet been added to Google!\n\n\nPython function to return pretty HTML popups for Folium map\ndef popup_func(pois: pd.DataFrame, i: int) -&gt; str:\n    \n    if not isinstance(pois.loc[i, 'google_name'], str):\n\n        # POI with no Google results\n        return f\"POI {str(i)}: {pois.loc[i, 'name']}\"\n    else:\n        \n        # Pretty HTML for POI details\n        return f\"\"\"\nPOI {str(i)}: &lt;a href=\\\"{pois.loc[i, 'url']}\\\"&gt;{pois.loc[i, 'google_name']}&lt;/a&gt;&lt;br&gt;\nRating: {pois.loc[i, 'rating']}&lt;br&gt;\nNumber of ratings: {int(pois.loc[i, 'n_ratings'])}&lt;br&gt;\nTags: {', '.join(eval(pois.loc[i, 'types'])).replace('_', ' ')}&lt;br&gt;\n&lt;img src=\\\"data:image/jpeg;base64,{pois.loc[i, 'photo_bytes']}\\\"&gt;\n    \"\"\"\n\n\n\nfolium_route(input_df[\"latitude\"], \n             input_df[\"longitude\"], \n             pois=pois,\n             popup_func=popup_func)\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook"
  }
]